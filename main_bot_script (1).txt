## botsucks

# Imports and Setup
import sys
print(sys.path)
import discord
from discord.ext import commands
import requests
import datetime
import pytz
from bs4 import BeautifulSoup  # Instead of 'import BeautifulSoup'
from io import BytesIO
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import sharppy
import sharppy.plot.skew as skew
import cartopy.crs as ccrs
import os
import json
import logging
from geopy.geocoders import Nominatim
import astropy.coordinates as coord
from astropy.time import Time
from timezonefinder import TimezoneFinder
import ephem
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
from PIL import Image
import numpy as np
import geocoder
import subprocess  
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import asyncio
import urllib.request
import openmeteo_requests
import requests_cache
import pandas as pd
from retry_requests import retry
from geopy.geocoders import Nominatim



def load_cache(cache_name):
    try:
        with open(f"{cache_name}_cache.json", "r") as file:
            return json.load(file)
    except FileNotFoundError:
        return {}  # Return an empty dictionary if the cache file doesn't exist


try:
    subprocess.run(["python", "main_bot_script.py"], check=True)
except subprocess.CalledProcessError as e:
    print(f"Error running script: {e.output}")

# Load Configuration
import config

# Configure logging
logging.basicConfig(
    filename="weather_bot.log",
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Initialize the bot
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix=config.COMMAND_PREFIX, intents=intents)

@bot.event
async def on_ready():
    print(f'We have logged in as {bot.user}') # idk i hope this works

# Data Storage (Caching)
metar_cache = {}
taf_cache = {}
alert_cache = {}

# Load Cache Data on Startup
metar_cache = load_cache("metar")  # keep getting and error with this line sometimes ohh
taf_cache = load_cache("taf") # guess maybe this one too
alert_cache = load_cache("alert") # this is gay

# Helper Functions for Caching (load_cache, save_cache)
def load_cache(cache_type):
    try:
        with open(f"{cache_type}_cache.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_cache(cache_type, data):
    with open(f"{cache_type}_cache.json", "w") as f:
        json.dump(data, f, indent=2)

# --- on_message Event Handler ---
@bot.event
async def on_message(message):
    if message.author == bot.user:  # Don't respond to self
        return


    await bot.process_commands(message)  # Process bot commands

# Helper Functions for Caching (load_cache, save_cache)
def load_cache(cache_type):
    try:
        with open(f"{cache_type}_cache.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_cache(cache_type, data):
    with open(f"{cache_type}_cache.json", "w") as f:
        json.dump(data, f, indent=2)

# Data Storage (Caching)
metar_cache = {}
taf_cache = {}
alert_cache = {}

# Load Cache Data on Startup
metar_cache = load_cache("metar")
taf_cache = load_cache("taf")
alert_cache = load_cache("alert")

# --- METAR Command ---
@bot.command(aliases=["wx"])
async def metar(ctx, airport_code: str, hours_ago: int = config.DEFAULT_HOURS_BEFORE_NOW_METAR):
    """Fetches METAR for the specified airport code. Optionally specify hours ago for historical data."""
    try:
        if hours_ago < 0:
            raise ValueError("Invalid hours ago. Please enter a non-negative number.")

        airport_code = airport_code.upper()

        # Check for cached METARs first (only if hours_ago is within cache range)
        if 0 <= hours_ago <= config.MAX_HOURS_METAR_CACHE:
            cached_metars = [
                entry for entry in metar_cache.get(airport_code, [])
                if (datetime.datetime.utcnow() - datetime.datetime.fromisoformat(entry['time'])).total_seconds() / 3600 <= hours_ago
            ]
            if cached_metars:
                for metar in cached_metars:
                    embed = discord.Embed(title=f"METAR for {airport_code}", description=metar['data'])
                    embed.set_footer(text=f"Observation Time: {metar['time']}Z")
                    await ctx.send(embed=embed)
                logging.info(f"User {ctx.author} requested METAR for {airport_code} (hours ago: {hours_ago}, cached)")
                return  # If found in cache, no need to fetch from API

        # If not in cache or requesting beyond cache range, fetch from API
        max_hours_to_fetch = min(hours_ago, config.MAX_HOURS_METAR_API_REQUEST)  # Limit API request to avoid overloading
        url = f"{config.AVIATION_WEATHER_URL}?dataSource=metars&requestType=retrieve&format=xml&stationString={airport_code}&hoursBeforeNow={max_hours_to_fetch}"

        response = requests.get(url)
        response.raise_for_status()

        soup = BeautifulSoup(response.content, 'xml')
        metar_elements = soup.find_all('METAR')  # Find all METAR elements

        if not metar_elements:
            raise ValueError("METAR data not found.")

        for metar_element in metar_elements:
            metar_data = metar_element.find('raw_text').text
            metar_time = metar_element.find('observation_time').text

            # Prepare and send response
            embed = discord.Embed(title=f"METAR for {airport_code}", description=metar_data)
            embed.set_footer(text=f"Observation Time: {metar_time}Z")
            await ctx.send(embed=embed)

            # Update cache (only for current METARs)
            if max_hours_to_fetch == 0:
                if airport_code not in metar_cache:
                    metar_cache[airport_code] = []
                metar_cache[airport_code].append({
                    "time": metar_time,
                    "data": metar_data
                })
                save_cache("metar", metar_cache)

        logging.info(f"User {ctx.author} requested METAR for {airport_code} (hours ago: {hours_ago})")

    except (requests.exceptions.RequestException, AttributeError, ValueError) as e:
        await ctx.send(f"Error retrieving/parsing METAR for {airport_code}: {e}")
        logging.error(f"Error retrieving/parsing METAR for {airport_code}: {e}")

# --- TAF Command ---
@bot.command()
async def taf(ctx, airport_code: str):
    """Fetches TAF for the specified airport code."""
    try:
        # 1. Input Handling and Caching
        airport_code = airport_code.upper()

        # Check for cached TAF (only if within cache range)
        if 0 <= config.DEFAULT_HOURS_BEFORE_NOW_TAF <= config.MAX_HOURS_TAF_CACHE:
            cached_tafs = [
                entry for entry in taf_cache.get(airport_code, [])
                if (datetime.datetime.utcnow() - datetime.datetime.fromisoformat(entry['time'])).total_seconds() / 3600 <= config.DEFAULT_HOURS_BEFORE_NOW_TAF
            ]
            if cached_tafs:
                for taf in cached_tafs:
                    embed = discord.Embed(title=f"TAF for {airport_code}", description=taf['data'])
                    embed.set_footer(text=f"Issue Time: {taf['time']}Z")
                    await ctx.send(embed=embed)
                logging.info(f"User {ctx.author} requested TAF for {airport_code} (cached)")
                return 

        # 2. Construct URL
        url = f"{config.AVIATION_WEATHER_URL}?dataSource=tafs&requestType=retrieve&format=xml&stationString={airport_code}&hoursBeforeNow={config.DEFAULT_HOURS_BEFORE_NOW_TAF}"

        # 3. Fetch Data
        response = requests.get(url)
        response.raise_for_status()  # Raise an exception for HTTP errors

        # 4. Parse TAF
        soup = BeautifulSoup(response.content, 'xml')

        # Check if any TAF data was found at all
        if not soup.find('data'):
            raise ValueError(f"No TAF data found for {airport_code}.")

        # Extract the latest TAF (assuming the first one is the most recent)
        taf_data = soup.find('raw_text').text
        taf_time = soup.find('issue_time').text

        if not taf_data or not taf_time:
            raise ValueError("TAF data or issue time not found.")

        # 5. Prepare and Send Response
        embed = discord.Embed(title=f"TAF for {airport_code}", description=taf_data)
        embed.set_footer(text=f"Issue Time: {taf_time}Z")
        await ctx.send(embed=embed)

        # 6. Update Cache (only for current TAFs)
        if config.DEFAULT_HOURS_BEFORE_NOW_TAF == 0:
            if airport_code not in taf_cache:
                taf_cache[airport_code] = []
            taf_cache[airport_code].append({
                "time": taf_time,  # Use the extracted taf_time
                "data": taf_data
            })
            save_cache("taf", taf_cache)

        logging.info(f"User {ctx.author} requested TAF for {airport_code}")

    # 7. Error Handling 
    except requests.exceptions.RequestException as e:
        await ctx.send(f"Error fetching TAF data for {airport_code}: {e}")
        logging.error(f"Error fetching TAF data for {airport_code}: {e}")
    except AttributeError as e:
        await ctx.send(f"Error parsing TAF data for {airport_code}: {e}")
        logging.error(f"Error parsing TAF data for {airport_code}: {e}")
    except ValueError as e:
        await ctx.send(e)  # Display the specific ValueError message to the user
        logging.error(f"ValueError in TAF command for {airport_code}: {e}")

# --- Skew-T Command ---
@bot.command()
async def skewt(ctx, station_code: str):
    """Fetches sounding data from the University of Wyoming and generates a Skew-T diagram."""

    try:
        station_code = station_code.upper()

        # Construct the URL for the Wyoming sounding archive
        sounding_url = f"https://weather.uwyo.edu/cgi-bin/sounding?region=naconf&TYPE=TEXT%3ALIST&YEAR=latest&MONTH=latest&FROM=0000&TO=2300&STNM={station_code}"

        # Fetch the sounding data
        response = requests.get(sounding_url)
        response.raise_for_status()

        # Parse the HTML to extract the sounding text
        soup = BeautifulSoup(response.content, 'html.parser')
        sounding_data = soup.find("pre").text.strip()

        if not sounding_data:
            raise ValueError("Sounding data not found.")

        # Generate the Skew-T diagram using SHARPpy
        profile = sharppy.Profile.from_sounding(sounding_data)
        fig = plt.figure(figsize=(8, 8))
        skew.plot(profile)

        # Prepare and send the image
        buffer = BytesIO()
        plt.savefig(buffer, format='png')
        buffer.seek(0)
        plt.close(fig)

        await ctx.send(file=discord.File(buffer, f"skewt_{station_code}_observed.png"))

    except (requests.exceptions.RequestException, AttributeError, ValueError) as e:
        await ctx.send(f"Error retrieving/parsing Skew-T data for {station_code}: {e}")

# once we get stuff like this fixed, the logo adding section needs to be fixed as well, then we can slap Marine Corps unit logos on other people's shit lmao. that parts easy i think

# --- Satellite Command ---
@bot.command()
async def sat(ctx, region: str, product_code: int):
    """Fetches satellite image for the specified region and product code using pre-defined links."""

    try:
        region = region.lower()
        valid_regions = ["conus", "fulldisk", "mesosector1", "mesosector2", "tropicalatlantic", "gomex", "ne"] 

        if region not in valid_regions:
            raise ValueError(f"Invalid region. Valid options are: {', '.join(valid_regions)}")

        # Product codes for different regions (updated with new regions and product codes)
        product_codes = {
            "conus": {1: "GeoColor (True Color)", 2: "Red Visible", 14: "Clean Longwave Infrared Window", 9: "Mid-level Water Vapor", 22: "RGB"},
            "fulldisk": {1: "GeoColor (True Color)", 2: "Red Visible", 13: "Clean Longwave Infrared Window", 9: "Mid-level Water Vapor"},
            "mesosector1": {1: "GeoColor (True Color)", 2: "Red Visible", 13: "Clean Longwave Infrared Window", 9: "Mid-level Water Vapor"},
            "mesosector2": {1: "GeoColor (True Color)", 2: "Red Visible", 13: "Clean Longwave Infrared Window", 9: "Mid-level Water Vapor"},
            "tropicalatlantic": {1: "GeoColor (True Color)", 2: "Red Visible", 14: "Clean Longwave Infrared Window", 9: "Mid-level Water Vapor", 22: "RGB"},
            "gomex": {2: "Red Visible", 14: "Clean Longwave Infrared Window", 9: "Mid-level Water Vapor"},
            "ne": {2: "Red Visible", 14: "Clean Longwave Infrared Window", 9: "Mid-level Water Vapor"},
        }

        # Error handling for invalid product code
        if product_code not in product_codes[region]:
            raise ValueError(f"Invalid product code for {region}. Valid codes are: {', '.join(map(str, product_codes[region].keys()))}")

        # Define image_links with the provided URLs (updated with new links 8/16/24)
        image_links = {
            ("conus", 14): "https://whirlwind.aos.wisc.edu/~wxp/goes16/ircm/conus/latest_conus_1.jpg",
            ("tropicalatlantic", 14): "https://whirlwind.aos.wisc.edu/~wxp/goes16/ircm/tropical_atlantic/latest_tropical_atlantic_1.jpg",
            ("mesosector1", 13): "https://whirlwind.aos.wisc.edu/~wxp/goes16/grb/meso_ircm/latest_meso_1.jpg",
            ("mesosector1", 9): "https://whirlwind.aos.wisc.edu/~wxp/goes16/grb/meso_wvc/latest_meso_1.jpg",
            ("fulldisk", 14): "https://whirlwind.aos.wisc.edu/~wxp/goes16/ircm/fulldisk_full/latest_fulldisk_full_1.jpg",
            ("fulldisk", 9): "https://whirlwind.aos.wisc.edu/~wxp/goes16/wvc/fulldisk_full/latest_fulldisk_full_1.jpg",
            ("mesosector2", 13): "https://whirlwind.aos.wisc.edu/~wxp/goes16/grb/meso_ircm/latest_meso_2.jpg",
            ("mesosector2", 9): "https://whirlwind.aos.wisc.edu/~wxp/goes16/grb/meso_wvc/latest_meso_2.jpg",
            ("mesosector2", 2): "https://whirlwind.aos.wisc.edu/~wxp/goes16/grb/meso_vis_sqrt/latest_meso_2.jpg",

            # New links
            ("gomex", 14): "https://whirlwind.aos.wisc.edu/~wxp/goes16/ircm/gulf/latest_gulf_1.jpg",
            ("gomex", 9): "https://whirlwind.aos.wisc.edu/~wxp/goes16/wvc/gulf/latest_gulf_1.jpg",
            ("gomex", 2): "https://whirlwind.aos.wisc.edu/~wxp/goes16/vis/gulf/latest_gulf_1.jpg",
            ("ne", 2): "https://whirlwind.aos.wisc.edu/~wxp/goes16/vis/ne/latest_ne_1.jpg",
            ("ne", 14): "https://whirlwind.aos.wisc.edu/~wxp/goes16/ircm/ne/latest_ne_1.jpg",
            ("ne", 9): "https://whirlwind.aos.wisc.edu/~wxp/goes16/wvc/ne/latest_ne_1.jpg",
            ("tropicalatlantic", 2): "https://whirlwind.aos.wisc.edu/~wxp/goes16/vis/tropical_atlantic/latest_tropical_atlantic_1.jpg",
            ("tropicalatlantic", 9): "https://whirlwind.aos.wisc.edu/~wxp/goes16/wvc/tropical_atlantic/latest_tropical_atlantic_1.jpg",
            ("tropicalatlantic", 22): "https://dustdevil.aos.wisc.edu/goes16/grb/rgb/tropical_atlantic/latest_tropical_atlantic_1.jpg",
            ("conus", 2): "https://whirlwind.aos.wisc.edu/~wxp/goes16/vis/conus/latest_conus_1.jpg",
            ("conus", 22): "https://dustdevil.aos.wisc.edu/goes16/grb/rgb/conus/latest_conus_1.jpg",
            ("conus", 9): "https://whirlwind.aos.wisc.edu/~wxp/goes16/wvc/conus/latest_conus_1.jpg"
            # ... add more links as needed, unless someone wants to do OCONUS stuff that's probably a wrap
        }

        # RBG under 22 is RAYLEIGH CORRECTED VISIBILITY not 'red green blue' or an airmass product

    except (requests.exceptions.RequestException, AttributeError, ValueError, KeyError) as e:
        await ctx.send(f"Error retrieving/parsing satellite imagery: {e}")

@bot.command()
async def astro(ctx, location: str = None):
    """Provides sunrise, sunset, moon phase, and twilight information for a given location."""
    if not location:
        await ctx.send("Please provide a location (e.g., '$astro New York City' or '$astro kmge'") # i haven't found a way to specify cities like the 95 jacksonvilles in the USA, so its a lot easier to just type in the ICAO
        return

    try:
        # Geocode location to get coordinates
        geolocator = Nominatim(user_agent="weather-bot")
        loc = geolocator.geocode(location)
        if not loc:
            raise ValueError("Location not found.")

        # Determine time zone
        tf = TimezoneFinder()
        timezone = tf.timezone_at(lng=loc.longitude, lat=loc.latitude)

        # Get current time in the specified time zone
        now = datetime.datetime.now(pytz.timezone(timezone))

        # Calculate sunrise, sunset, and twilight times using PyEphem
        obs = ephem.Observer()
        obs.lat = str(loc.latitude)
        obs.long = str(loc.longitude)
        obs.date = now
        sun = ephem.Sun()
        moon = ephem.Moon()

        sunrise = obs.next_rising(sun).datetime().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))
        sunset = obs.next_setting(sun).datetime().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))

        # Twilight calculations
        obs.horizon = '-0:34'  # Civil twilight
        civil_twilight_begin = obs.previous_rising(sun, use_center=True).datetime().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))
        civil_twilight_end = obs.next_setting(sun, use_center=True).datetime().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))

        obs.horizon = '-6'  # Civil twilight
        nautical_twilight_begin = obs.previous_rising(sun, use_center=True).datetime().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))
        nautical_twilight_end = obs.next_setting(sun, use_center=True).datetime().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))

        obs.horizon = '-12'  # Astronomical twilight
        astronomical_twilight_begin = obs.previous_rising(sun, use_center=True).datetime().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))
        astronomical_twilight_end = obs.next_setting(sun, use_center=True).datetime().replace(tzinfo=pytz.UTC).astimezone(pytz.timezone(timezone))

        # Calculate moon phase
        moon.compute(now)
        moon_phase = moon.phase

        # Format the results
        response = f"Astronomy information for {location}:\n\n"
        response += f"**Sunrise:** {sunrise.strftime('%Y-%m-%d %I:%M %p %Z')}\n"
        response += f"**Sunset:** {sunset.strftime('%Y-%m-%d %I:%M %p %Z')}\n"
        response += f"**Civil Twilight Begin:** {civil_twilight_begin.strftime('%Y-%m-%d %I:%M %p %Z')}\n"
        response += f"**Civil Twilight End:** {civil_twilight_end.strftime('%Y-%m-%d %I:%M %p %Z')}\n"
        response += f"**Nautical Twilight Begin:** {nautical_twilight_begin.strftime('%Y-%m-%d %I:%M %p %Z')}\n"
        response += f"**Nautical Twilight End:** {nautical_twilight_end.strftime('%Y-%m-%d %I:%M %p %Z')}\n"
        response += f"**Astronomical Twilight Begin:** {astronomical_twilight_begin.strftime('%Y-%m-%d %I:%M %p %Z')}\n"
        response += f"**Astronomical Twilight End:** {astronomical_twilight_end.strftime('%Y-%m-%d %I:%M %p %Z')}\n"
        response += f"**Moon Phase:** {moon_phase:.1f}% (Illuminated)"

        await ctx.send(response)
        logging.info(f"User {ctx.author} requested astronomy information for {location}")
    except (GeocoderTimedOut, AttributeError, ValueError) as e:
        await ctx.send(f"Error retrieving astronomy information: {e}")
        logging.error(f"Error retrieving astronomy information for {location}: {e}")

# --- Radar Command ---
@bot.command()
async def radar(ctx, region: str = "plains", overlay: str = "base"):  # Changed default overlay to "base"
    """Displays a radar image for the specified region and overlay type."""

    try:
        region = region.lower()
        overlay = overlay.lower()

        valid_regions = ["plains", "ne", "se", "sw", "nw"] 
        valid_overlays = ["base", "totals"]  # Replaced "none" with "base"

        if region not in valid_regions:
            raise ValueError(f"Invalid region. Valid options are: {', '.join(valid_regions)}")
        if overlay not in valid_overlays:
            raise ValueError(f"Invalid overlay. Valid options are: {', '.join(valid_overlays)}")

        # Radar image links (updated with "base" instead of "none")
        image_links = {
            ("plains", "base"): "https://tempest.aos.wisc.edu/radar/plains3comp.gif",
            ("plains", "totals"): "https://tempest.aos.wisc.edu/radar/plainsPcomp.gif",
            ("ne", "base"): "https://tempest.aos.wisc.edu/radar/ne3comp.gif",
            ("ne", "totals"): "https://tempest.aos.wisc.edu/radar/nePcomp.gif",
            ("se", "base"): "https://tempest.aos.wisc.edu/radar/se3comp.gif",
            ("se", "totals"): "https://tempest.aos.wisc.edu/radar/sePcomp.gif",
            ("sw", "base"): "https://tempest.aos.wisc.edu/radar/sw3comp.gif",
            ("sw", "totals"): "https://tempest.aos.wisc.edu/radar/swPcomp.gif",
            ("nw", "base"): "https://tempest.aos.wisc.edu/radar/nw3comp.gif",
            ("nw", "totals"): "https://tempest.aos.wisc.edu/radar/nwPcomp.gif",
            # ... should be all the links we need for radar, like I said not looking for anything fancy here because obviously we use things like radarscope and grlevel3, but having a bot that can pull an image that's ready to save and post
	    # is better than having to go to this website and click through the 95 links, right click, possibly needing change the format. you get what i mean
        }

       

    except (requests.exceptions.RequestException, ValueError) as e:
        await ctx.send(f"Error retrieving radar image: {e}")

# --- Models Command, under the command $weather ---
# Setup the Open-Meteo API client with cache and retry on error
cache_session = requests_cache.CachedSession('.cache', expire_after=3600)
retry_session = retry(cache_session, retries=5, backoff_factor=0.2)
openmeteo = openmeteo_requests.Client(session=retry_session)   


@bot.command()
async def weather(ctx, location: str, *, variables: str = None):
    """Fetches hourly weather data for a specified location from Open-Meteo."""

    try:
        # 1. Get coordinates for the location (you might need to implement this)
        latitude, longitude = get_coordinates(location)  # Implement this function

        # 2. Define the list of weather variables to fetch
        available_variables = [
            "temperature_2m", "relative_humidity_2m", "dew_point_2m", 
            "apparent_temperature", "precipitation_probability", "precipitation", 
            "rain", "showers", "snowfall", "snow_depth", "weather_code", 
            "pressure_msl", "surface_pressure", "cloud_cover", "cloud_cover_low", 
            "cloud_cover_mid", "cloud_cover_high", "visibility", "evapotranspiration", 
            "et0_fao_evapotranspiration", "vapour_pressure_deficit", "wind_speed_10m", 
            "wind_speed_80m", "wind_direction_10m",   
 "wind_direction_80m", "wind_gusts_10m", 
            "temperature_80m", "surface_temperature", "soil_temperature_0_to_10cm", 
            "soil_temperature_10_to_40cm", "uv_index", "sunshine_duration", "cape", 
            "lifted_index", "convective_inhibition", "freezing_level_height", 
            "temperature_1000hPa", "temperature_925hPa", "temperature_850hPa", 
            "temperature_700hPa", "temperature_500hPa", "temperature_300hPa", 
            "dew_point_1000hPa", "dew_point_925hPa", "dew_point_800hPa", 
            "dew_point_700hPa", "dew_point_500hPa", "dew_point_300hPa", 
            "wind_speed_1000hPa", "wind_speed_925hPa", "wind_speed_850hPa", 
            "wind_speed_700hPa", "wind_speed_500hPa", "wind_speed_300hPa", 
            "wind_direction_1000hPa", "wind_direction_925hPa", "wind_direction_850hPa", 
            "wind_direction_700hPa", "wind_direction_500hPa", "wind_direction_300hPa", 
            "vertical_velocity_1000hPa", "vertical_velocity_925hPa", "vertical_velocity_850hPa", 
            "vertical_velocity_700hPa", "vertical_velocity_500hPa", "vertical_velocity_300hPa", 
            "geopotential_height_1000hPa", "geopotential_height_925hPa", "geopotential_height_850hPa", 
            "geopotential_height_700hPa", "geopotential_height_500hPa", "geopotential_height_300hPa"
        ]

        if variables:
            requested_variables = [var.strip() for var in variables.split(',')]
            # Check if requested variables are valid
            invalid_variables = [var for var in requested_variables if var not in available_variables]
            if invalid_variables:
                await ctx.send(f"Invalid variables: {', '.join(invalid_variables)}. Available variables: {', '.join(available_variables)}")
                return
        else:
            # Default to some basic variables if none are specified
            requested_variables = ["temperature_2m", "precipitation_probability", "wind_speed_10m"]

        # 3. Fetch weather data
        url = "https://api.open-meteo.com/v1/forecast"
        params = {
            "latitude": latitude,
            "longitude": longitude,
            "hourly": requested_variables,
            "wind_speed_unit": "kn",
            "precipitation_unit": "inch",
            "timezone": "America/New_York",  # Adjust timezone if needed
            "past_hours": 6,
            "forecast_hours": 12,
            "models": ["gfs_seamless", "gfs_global", "gfs_hrrr", "gfs_graphcast025"]  # Adjust models if needed
        }
        responses = openmeteo.weather_api(url, params=params)
        response = responses[0]

        # 4. Process hourly data
        hourly = response.Hourly()
        hourly_data = {"date": pd.date_range(
            start=pd.to_datetime(hourly.Time(), unit="s", utc=True),
            end=pd.to_datetime(hourly.TimeEnd(), unit="s", utc=True),
            freq=pd.Timedelta(seconds=hourly.Interval()),
            inclusive="left"
        )}
        for i, var_name in enumerate(requested_variables):
            hourly_data[var_name] = hourly.Variables(i).ValuesAsNumpy()

        hourly_dataframe = pd.DataFrame(data=hourly_data)

        # 5. Create and send embedded message (you'll likely want to customize this further)
        embed = discord.Embed(title=f"Weather Forecast for {location}", color=discord.Color.blue())
        for var_name in requested_variables:
            embed.add_field(name=var_name, value=hourly_dataframe[var_name].to_string(index=False), inline=False)

        await ctx.send(embed=embed)

    except Exception as e:
        await ctx.send(f"Error fetching weather data: {e}")

def get_coordinates(location):
    """Gets the latitude and longitude for a given location using Nominatim."""

    geolocator = Nominatim(user_agent="WeatherBot")  # Replace with your bot's name in "_"
    location_obj = geolocator.geocode(location)

    if location_obj:
        return location_obj.latitude, location_obj.longitude
    else:
        return None

# --- ASCAT Command ---
@bot.command()
async def ascat(ctx, storm_id: str = None):
    """Fetches ASCAT images for the specified storm from FNMOC. If no storm_id is provided, it will list the active storms."""

    try:
        # Fetch the main FNMOC TCWEB page
        base_url = "https://www.fnmoc.navy.mil/tcweb/cgi-bin/tc_home.cgi"
        response = requests.get(base_url)
        response.raise_for_status()

        # Parse the HTML to find active storms
        soup = BeautifulSoup(response.content, 'html.parser')
        active_storms = extract_active_storms(soup)  # Replace with your actual parsing logic

        if storm_id is None:
            # If no storm_id is provided, list the active storms
            if active_storms:
                await ctx.send(f"Currently active storms: {', '.join(active_storms)}")
            else:
                await ctx.send("No active storms found.")
            return  # Exit the command early

        # Check if the requested storm is active
        if storm_id.upper() not in [s.upper() for s in active_storms]:
            raise ValueError(f"Storm '{storm_id}' not found among active storms. Currently active storms are: {', '.join(active_storms)}")

        # Construct the URL for the storm's ASCAT image page (adjust as needed)
        storm_url = f"{base_url}?YEAR=2024&MO=Aug&BASIN=ATL&STORM_NAME={storm_id}&SENSOR=&PHOT=yes&ARCHIVE=Mosaic&NAV=tc&DISPLAY=all&MOSAIC_SCALE=20%&STYLE=table&ACTIVES={','.join(active_storms)}&TYPE=ascat&CURRENT=LATEST.jpg&PROD=hires&DIR=/tcweb/dynamic/products/tc24/ATL/{storm_id}/ascat/hires&file_cnt=160"

        # Fetch the storm's ASCAT image page
        response = requests.get(storm_url)
        response.raise_for_status()

        # Parse the HTML to extract image URLs
        soup = BeautifulSoup(response.content, 'html.parser')
        image_urls = extract_image_urls(soup)  # Replace with your actual parsing logic

        # Download and send images
        for image_url in image_urls:
            image_filename = image_url.split('/')[-1]
            urllib.request.urlretrieve(image_url, image_filename)
            await ctx.send(file=discord.File(image_filename))

    except (requests.exceptions.RequestException, AttributeError, ValueError) as e:
        await ctx.send(f"Error retrieving/parsing ASCAT imagery: {e}")

# Placeholder functions for parsing (you'll need to implement these)
def extract_active_storms(soup):
    """Parses the BeautifulSoup object (soup) to extract a list of active storm IDs."""
    # ... your implementation here
    pass

def extract_image_urls(soup):
    """Parses the BeautifulSoup object (soup) to extract a list of image URLs."""
    # ... your implementation here
    pass


# --- Overlay/Logo Section ---
def add_map_overlay(ax, lat=None, lon=None, icon_path=None, logo_path="logo.png", zoom=0.1):
    """Adds a marker (if lat/lon provided) and a logo to the map image.

    Args:
        ax: The Matplotlib Axes object representing the map.
        lat (float, optional): Latitude of the marker (if needed). Defaults to None.
        lon (float, optional): Longitude of the marker (if needed). Defaults to None.
        icon_path (str, optional): Path to the marker icon image. Defaults to None.
        logo_path (str, optional): Path to the logo image file. Defaults to "logo.png".
        zoom (float, optional): Zoom level for the marker icon. Defaults to 0.1.
    """

    # 1. Add Location Marker (if coordinates are provided)
    if lat is not None and lon is not None:
        try:
            if icon_path:  # Use custom icon if provided
                img = Image.open(icon_path)
            else:  # Use default marker icon
                img = Image.open("default_marker.png")  # Replace with your default icon
        except (FileNotFoundError, PIL.UnidentifiedImageError):
            logging.warning("Error loading marker icon. Using default.")
            img = Image.open("default_marker.png")

        imagebox = OffsetImage(img, zoom=zoom)
        ab = AnnotationBbox(imagebox, (lon, lat), xycoords=ccrs.PlateCarree()._as_mpl_transform(ax),
                           boxcoords="offset points", pad=0, zorder=10)  # Higher zorder to place above other elements
        ax.add_artist(ab)
        ax.annotate(f"({lat:.2f}, {lon:.2f})", (lon, lat), xytext=(3, 3), textcoords="offset points", zorder=10)

    # 2. Add Logo
    try:
        logo_img = Image.open(logo_path)
    except (FileNotFoundError, PIL.UnidentifiedImageError):
        logging.warning("Error loading logo. Skipping logo overlay.")
        return  # Exit function if logo cannot be loaded

    logo_img.thumbnail((25, 25))  # Resize logo to 25x25 pixels

    # Calculate logo position with margin
    dpi = 100
    margin_pixels = int(1 * dpi)  # 1 cm margin
    x_pos = ax.get_xlim()[1] - logo_img.width - margin_pixels
    y_pos = ax.get_ylim()[0] + margin_pixels

    logo = OffsetImage(logo_img)
    ab_logo = AnnotationBbox(logo, (x_pos, y_pos),
                            frameon=False,
                            xycoords='data',
                            boxcoords="offset points",
                            box_alignment=(1, 0),
                            zorder=10)
    ax.add_artist(ab_logo)

# --- Placeholder Commands (these might or might not work or have 95 trillion bugs) ---

# lets do unit conversion
# Conversion Factors Dictionary
conversion_factors = {
    "length": {
        "in": {"mm": 25.4, "cm": 2.54, "m": 0.0254, "km": 2.54e-5},
        "ft": {"m": 0.3048, "km": 0.0003048},
        "yd": {"m": 0.9144, "km": 0.0009144},
        "mi": {"km": 1.60934},
        "mm": {"in": 0.0393701},
        "cm": {"in": 0.393701},
        "m": {"ft": 3.28084, "yd": 1.09361, "mi": 0.000621371},
        "km": {"mi": 0.621371},
    },
    "area": {
        "in²": {"cm²": 6.4516, "m²": 0.00064516, "ft²": 0.00694444}, 
        "ft²": {"m²": 0.092903, "yd²": 0.111111},
        "yd²": {"m²": 0.836127, "ft²": 9},
        "mi²": {"km²": 2.58999},
        "cm²": {"in²": 0.15500031},
        "m²": {"ft²": 10.7639, "yd²": 1.19599},
        "km²": {"mi²": 0.386102},
    },
    "volume": {
        "in³": {"cm³": 16.3871, "ml": 16.3871, "L": 0.0163871},
        "ft³": {"m³": 0.0283168, "L": 28.3168, "gal": 7.48052},
        "yd³": {"m³": 0.764555},
        "gal": {"L": 3.78541, "qt": 4, "pt": 8, "c": 16, "floz": 128},
        "oz": {"ml": 29.5735}, # Fluid ounce
        "ml": {"oz": 0.033814},
        "L": {"gal": 0.264172, "qt": 1.05669, "pt": 2.11338},
        "m³": {"ft³": 35.3147, "yd³": 1.30795},
        "qt": {"L": 0.946353, "pt": 2, "c": 4, "floz": 32},
        "pt": {"L": 0.473176, "c": 2, "floz": 16},
        "c": {"L": 0.236588, "floz": 8},
        "floz": {"L": 0.0295735}, # Fluid ounce
    },
    "mass": {
        "oz": {"g": 28.3495},
        "lb": {"g": 453.592, "kg": 0.453592},
        "g": {"oz": 0.035274, "lb": 0.00220462},
        "kg": {"lb": 2.20462},
        "ton": {"kg": 1000},  # Metric ton (tonne)
    },
    "temperature": { 
        "°F": {"°C": (lambda x: (x - 32) * 5/9), "K": (lambda x: (x - 32) * 5/9 + 273.15)},
        "°C": {"°F": (lambda x: (x * 9/5) + 32), "K": (lambda x: x + 273.15)},
        "K": {"°C": (lambda x: x - 273.15), "°F": (lambda x: (x - 273.15) * 9/5 + 32)},
    },
}

def convert_unit(value, from_unit, to_unit):
    """Converts a value between different units."""

    for category in conversion_factors:
        if from_unit.lower() in conversion_factors[category] and to_unit.lower() in conversion_factors[category][from_unit.lower()]:
            conversion_factor = conversion_factors[category][from_unit.lower()][to_unit.lower()]
            if callable(conversion_factor):
                converted_value = conversion_factor(value)
            else:
                converted_value = value * conversion_factor

            return f"{value}{from_unit} is equal to {converted_value:.2f}{to_unit}"

    return "Invalid unit conversion."

# --- Conversion Command ---
@bot.command()
async def conv(ctx, value: float, from_unit: str, _, to_unit: str):  # '_' captures the 'to' keyword
    """Converts a value from one unit to another."""
    try:
        result = convert_unit(value, from_unit, to_unit)
        await ctx.send(result)
    except ValueError as e:
        await ctx.send(e)

state_abbreviations_to_fips = {
    'al': '01', 'ak': '02', 'az': '04', 'ar': '05', 'ca': '06', 'co': '08', 'ct': '09', 'de': '10', 'fl': '12', 
    'ga': '13', 'hi': '15', 'id': '16', 'il': '17', 'in': '18', 'ia': '19', 'ks': '20', 'ky': '21', 'la': '22', 
    'me': '23', 'md': '24', 'ma': '25', 'mi': '26', 'mn': '27', 'ms': '28', 'mo': '29', 'mt': '30', 'ne': '31', 
    'nv': '32', 'nh': '33', 'nj': '34', 'nm': '35', 'ny': '36', 'nc': '37', 'nd': '38', 'oh': '39', 'ok': '40', 
    'or': '41', 'pa': '42', 'ri': '44', 'sc': '45', 'sd': '46', 'tn': '47', 'tx': '48', 'ut': '49', 'vt': '50', 
    'va': '51', 'wa': '52', 'wv': '53', 'wi': '54', 'wy': '56'
}

# --- Alerts Command ---
@bot.command()
async def alerts(ctx, location: str = None):
    """Fetches and displays current weather alerts for a specified location or the user's location."""

    if location is None:
        # ... (same as before, handle user location if not provided)

    location = location.lower()  # Convert input to lowercase for easier comparison

    if location in state_abbreviations_to_fips:
        state_fips = state_abbreviations_to_fips[location]
        alerts_url = f"https://api.weather.gov/alerts/active?area={state_fips}" 
    else:
        # ... (handle other location types if needed, or provide an error message)
        await ctx.send("Invalid location. Please provide a two-letter state abbreviation (e.g., 'ga' for Georgia).")
        return

    response = requests.get(alerts_url)

    if response.status_code == 200:
        alerts_data = response.json()

        filtered_alerts = []
        for alert in alerts_data['features']:
            event = alert['properties']['event']
            severity = alert['properties']['severity']

            # Customize filtering criteria here if needed
            filtered_alerts.append(alert)

        if filtered_alerts:
            for alert in filtered_alerts:
                properties = alert['properties']
                embed = discord.Embed(
                    title=properties['headline'],
                    color=discord.Color.red() 
                )
                embed.add_field(name="Severity", value=properties['severity'], inline=True)
                embed.add_field(name="Effective", value=properties['onset'], inline=True)
                embed.add_field(name="Expires", value=properties['expires'], inline=True)
                embed.add_field(name="Area", value=", ".join(properties['areaDesc']), inline=False)
                embed.add_field(name="Description", value=properties['description'], inline=False)
                embed.add_field(name="Instructions", value=properties['instruction'] or "None", inline=False)
                await ctx.send(embed=embed)
        else:
            await ctx.send("No weather alerts found for the specified location.")

    else:
        await ctx.send(f"Error fetching alerts: {response.status_code}")


# --- Lightning Command ---
@bot.command()
async def lightning(ctx, icao: str, radius: int = 5):
    """Checks for lightning strikes within a specified radius of an ICAO airport."""

    try:
        # 1. Get airport coordinates (you'll need to implement this function)
        airport_coords = get_airport_coordinates(icao)
        if airport_coords is None:
            await ctx.send(f"Could not find airport with ICAO code {icao}.")
            return

        # 2. Construct the API URL (replace with your actual credentials)
        api_url = f'https://data.api.xweather.com/lightning/{airport_coords[0]},{airport_coords[1]}?format=json&filter=cg&limit=10&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET'

        # 3. Fetch lightning data
        request = urllib.request.urlopen(api_url)
        response = request.read()
        data = json.loads(response)
        request.close()

        # 4. Check for success and process data
        if data['success']:
            lightning_data = data['data']

            # 5. Check for strikes within the radius
            has_lightning = any(
                distance(strike['latitude'], strike['longitude'], airport_coords[0], airport_coords[1]) <= radius
                for strike in lightning_data
            )

            # 6. Send the result
            if has_lightning:
                await ctx.send(f"Lightning detected within {radius} miles of {icao}.")
            else:
                await ctx.send(f"No lightning detected within {radius} miles of {icao}.")

        else:
            await ctx.send(f"An error occurred: {data['error']['description']}")

    except Exception as e:
        await ctx.send(f"Error checking for lightning: {e}")

# need to implement this function to get airport coordinates
def get_airport_coordinates(icao):
    # ... (futureeeee code here)

# need to implement this function to calculate distance
def distance(lat1, lon1, lat2, lon2):
   # ... (futureeeee code here, you can use the Haversine formula or a library like geopy)


# --- Webcam Command ---
# pip install selenium???
@bot.command()
async def webcam(ctx, location: str):
    """Displays a weather webcam image for a specified location."""

    try:
        # 1. Set up Selenium WebDriver
        options = webdriver.ChromeOptions()
        options.add_argument('--headless=new')  # Run in headless mode (no visible browser window)
        driver = webdriver.Chrome(options=options)

        # 2. Navigate to WeatherBug webcam page
        driver.get("https://www.weatherbug.com/weather-camera/")

        # 3. Search for the location
        search_box = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "locationSearch"))
        )
        search_box.send_keys(location)
        search_box.submit()

        # 4. Wait for the results to load and find the first webcam image
        webcam_image = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, ".camera-card img"))
        )
        image_url = webcam_image.get_attribute('src')

        # 5. Send the image to Discord
        await ctx.send(image_url)

    except Exception as e:
        await ctx.send(f"Error retrieving webcam image: {e}")

    finally:
        driver.quit()  # Close the browser window

@bot.command()
async def help(ctx):
    """Displays a help message with available commands and their descriptions."""

    embed = discord.Embed(title="Weather Bot Help", color=discord.Color.blue())
    embed.add_field(name="$metar <airport_code> [hours_ago]", value="Fetches METAR for the specified airport code. Optionally specify hours ago for historical data.", inline=False)
    embed.add_field(name="$taf <airport_code>", value="Fetches TAF for the specified airport code.", inline=False)
    embed.add_field(name="$skewt <station_code>", value="Fetches sounding data and generates a Skew-T diagram.", inline=False)
    embed.add_field(name="$sat <region> <product_code>", value="Fetches satellite image for the specified region and product code.", inline=False)
    embed.add_field(name="$astro <location>", value="Provides sunrise, sunset, and moon phase information for a given location.", inline=False)
    embed.add_field(name="$radar <region> [overlay]", value="Displays a radar image for the specified region and overlay type.", inline=False)
    embed.add_field(name="$weather <location> [variables]", value="Fetches hourly weather data for a specified location from Open-Meteo.", inline=False)
    embed.add_field(name="$ascat [storm_id]", value="Fetches ASCAT images for the specified storm from FNMOC. If no storm_id is provided, it will list the active storms.", inline=False)
    embed.add_field(name="$conv <value> <from_unit> to <to_unit>", value="Converts a value from one unit to another.", inline=False)
    embed.add_field(name="$alerts <location>", value="Fetches and displays current weather alerts for a specified location or the user's location.", inline=False)
    embed.add_field(name="$lightning <icao> [radius]", value="Checks for lightning strikes within a specified radius of an ICAO airport.", inline=False)
    embed.add_field(name="$webcam <location>", value="Displays a weather webcam image for a specified location.", inline=False)

    await ctx.send(embed=embed)
# well i tried updating this some

# i did have a help section that belongs here but it was giving me problems so i deleted it, not that important, but somehow it still works. This isn't the actual working script either, I think there's a loop bug within this script right
# here that im unaware of that was in need to be deleted in order for the bot to boot up. idk
